\hypertarget{namespaceaestate_1_1opera_1_1_d_b_pool_1_1simple__pooled__pg}{}\doxysection{aestate.\+opera.\+D\+B\+Pool.\+simple\+\_\+pooled\+\_\+pg 命名空间参考}
\label{namespaceaestate_1_1opera_1_1_d_b_pool_1_1simple__pooled__pg}\index{aestate.opera.DBPool.simple\_pooled\_pg@{aestate.opera.DBPool.simple\_pooled\_pg}}
\doxysubsection*{类}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classaestate_1_1opera_1_1_d_b_pool_1_1simple__pooled__pg_1_1_pooled_pg}{Pooled\+Pg}}
\item 
class \mbox{\hyperlink{classaestate_1_1opera_1_1_d_b_pool_1_1simple__pooled__pg_1_1_pooled_pg_connection}{Pooled\+Pg\+Connection}}
\end{DoxyCompactItemize}


\doxysubsection{详细描述}
\begin{DoxyVerb}SimplePooledPg - a very simple classic PyGreSQL connection pool.

Implements a pool of threadsafe cached connections
to a PostgreSQL database which are transparently reused,
using the classic (not DB-API 2 compliant) PyGreSQL pg API.

This should result in a speedup for persistent applications
such as the "Webware for Python" AppServer.

For more information on PostgreSQL, see:
    https://www.postgresql.org/
For more information on PyGreSQL, see:
    http://www.pygresql.org
For more information on Webware for Python, see:
    https://webwareforpython.github.io/w4py/

Measures are taken to make the pool of connections threadsafe
regardless of the fact that the PyGreSQL pg module itself is
not threadsafe at the connection level.  Connections will never be
shared between threads, so you can safely use transactions.

Usage:

The idea behind SimplePooledPg is that it's completely transparent.
After you have established your connection pool, stating the
number of connections to be cached in the pool and the
connection parameters, e.g.

    from dbutils.simple_pooled_pg import PooledPg
    dbpool = PooledPg(5, host=..., database=..., user=..., ...)

you can demand database connections from that pool,

    db = dbpool.connection()

and use them just as if they were ordinary PyGreSQL pg API
connections.  It's really just a proxy class.

db.close() will return the connection to the pool, it will not
actually close it.  This is so your existing code works nicely.

Ideas for improvement:

* Do not create the maximum number of connections on startup
already, but only a certain number and the rest on demand.
* Detect and transparently reset "bad" connections.  The PyGreSQL
pg API provides a status attribute and a reset() method for that.
* Connections should have some sort of "maximum usage limit"
after which they should be automatically closed and reopened.
* Prefer or enforce thread affinity for the connections.

Please note that these and other ideas have been already
implemented in in PooledPg, a more sophisticated version
of SimplePooledPg.  You might also consider using PersistentPg
instead for thread-affine persistent PyGreSQL connections.
SimplePooledPg may still serve as a very simple reference
and example implementation for developers.


Copyright, credits and license:

* Contributed as supplement for Webware for Python and PyGreSQL
  by Christoph Zwerschke in September 2005
* Based on the code of DBPool, contributed to Webware for Python
  by Dan Green in December 2000

Licensed under the MIT license.
\end{DoxyVerb}
 