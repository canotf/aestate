\hypertarget{namespaceaestate_1_1work_1_1_annotation}{}\doxysection{aestate.\+work.\+Annotation 命名空间参考}
\label{namespaceaestate_1_1work_1_1_annotation}\index{aestate.work.Annotation@{aestate.work.Annotation}}
\doxysubsection*{函数}
\begin{DoxyCompactItemize}
\item 
def \mbox{\hyperlink{namespaceaestate_1_1work_1_1_annotation_a0c2a2efda9eb54562253e840bb5d0f49}{Table}} (name, msg, $\ast$$\ast$kwargs)
\item 
def \mbox{\hyperlink{namespaceaestate_1_1work_1_1_annotation_ac08818b3674c675825f79597c16a79dd}{Select}} (str sql)
\item 
def \mbox{\hyperlink{namespaceaestate_1_1work_1_1_annotation_aff598086972f97be72f7422f46108015}{Select\+Abst}} ()
\item 
def \mbox{\hyperlink{namespaceaestate_1_1work_1_1_annotation_a53f3face99e699b9b9d5ea7a3d87e20d}{Aop\+Model}} (before=None, after=None, before\+\_\+args=None, before\+\_\+kwargs=None, after\+\_\+args=None, after\+\_\+kwargs=None)
\item 
def \mbox{\hyperlink{namespaceaestate_1_1work_1_1_annotation_ac32df9034e26df39f1e2e10d6a8015ec}{Read\+Xml}} (filename)
\item 
def \mbox{\hyperlink{namespaceaestate_1_1work_1_1_annotation_a52eec5f05b70859de00c6b2a0ebefcb5}{Item}} (id)
\end{DoxyCompactItemize}


\doxysubsection{函数说明}
\mbox{\Hypertarget{namespaceaestate_1_1work_1_1_annotation_a53f3face99e699b9b9d5ea7a3d87e20d}\label{namespaceaestate_1_1work_1_1_annotation_a53f3face99e699b9b9d5ea7a3d87e20d}} 
\index{aestate.work.Annotation@{aestate.work.Annotation}!AopModel@{AopModel}}
\index{AopModel@{AopModel}!aestate.work.Annotation@{aestate.work.Annotation}}
\doxysubsubsection{\texorpdfstring{AopModel()}{AopModel()}}
{\footnotesize\ttfamily def aestate.\+work.\+Annotation.\+Aop\+Model (\begin{DoxyParamCaption}\item[{}]{before = {\ttfamily None},  }\item[{}]{after = {\ttfamily None},  }\item[{}]{before\+\_\+args = {\ttfamily None},  }\item[{}]{before\+\_\+kwargs = {\ttfamily None},  }\item[{}]{after\+\_\+args = {\ttfamily None},  }\item[{}]{after\+\_\+kwargs = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}    AOP切面模式：
        依赖AopModel装饰器,再在方法上加入@AopModel即可切入编程


    优点:

        当使用@AopModel时,内部函数将会逐级调用回调函数,执行循序是:
            - func(*self.args, **self.kwargs)
            - func(*self.args)
            - func(**self.kwargs)
            - func()
        这将意味着,如果你的参数传入错误时,AopModel依旧会遵循原始方法所使用的规则,最令人大跌眼镜的使用方法就是:
<code>
            def Before(**kwargs):
                print('Before:', kwargs)
            # 此处的Before方法未存在args参数,而使用@AopModel时却传入了args
            @AopModel(before=Before,before_args=(0,1,2), before_kwargs={'1': '1'})
            def find_title_and_selects(self, **kwargs):

                print('function task', kwargs['uid'])

                _r = self.orm.find().where(index="<<100").end()

                print(_r)

                return _r
</code>
        其中包含参数有:
            before:切入时需要执行的函数

            before_args:切入的参数
                传入的列表或元组类型数据
                如果是需要使用当前pojo中的内容时，传参格式为:(pojo.字段名)
                可扩展格式，例如需要传入字典

            before_kwargs:切入的参数 -- 传入的字典数据

            after:切出前需要执行的参数

            after_args:切出的参数
                传入的列表或元组类型数据
                如果是需要使用当前pojo中的内容时，传参格式为:('self.字段名')
                可扩展格式，例如需要传入字典:('self.dict.key')

            after_kwargs:切出的参数 -- 传入的字典数据


    执行流程:

        Before->original->After

    Before注意事项:

        使用该参数时，方法具有返回值概不做处理,需要返回值内容可使用`global`定义一个全局字段用于保存数值

        当无法解析或者解析失败时m将使用pass关键字忽略操作

    After注意事项:

        使用该参数时，必须搭配至少一个result=None的kwargs存在于方法的形参中,

        当original方法执行完成将把返回值固定使用result键值对注入到该函数中

        当无法解析或者解析失败时m将使用pass关键字忽略操作



    Attributes:

         before:切入时需要执行的函数

         after:切出前需要执行的参数

         before_args:切入的参数
            传入的列表或元组类型数据
            如果是需要使用当前pojo中的内容时，传参格式为:(pojo.字段名)
            可扩展格式，例如需要传入字典

         before_kwargs:切入的参数 -- 传入的字典数据

         after_args:切出的参数
            传入的列表或元组类型数据
            如果是需要使用当前pojo中的内容时，传参格式为:('self.字段名')
            可扩展格式，例如需要传入字典:('self.dict.key')

         after_kwargs:切出的参数 -- 传入的字典数据\end{DoxyVerb}
 

在文件 Annotation.\+py 第 106 行定义.

\mbox{\Hypertarget{namespaceaestate_1_1work_1_1_annotation_a52eec5f05b70859de00c6b2a0ebefcb5}\label{namespaceaestate_1_1work_1_1_annotation_a52eec5f05b70859de00c6b2a0ebefcb5}} 
\index{aestate.work.Annotation@{aestate.work.Annotation}!Item@{Item}}
\index{Item@{Item}!aestate.work.Annotation@{aestate.work.Annotation}}
\doxysubsubsection{\texorpdfstring{Item()}{Item()}}
{\footnotesize\ttfamily def aestate.\+work.\+Annotation.\+Item (\begin{DoxyParamCaption}\item[{}]{id }\end{DoxyParamCaption})}



在文件 Annotation.\+py 第 236 行定义.

这是这个函数的调用关系图\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d9/db8/namespaceaestate_1_1work_1_1_annotation_a52eec5f05b70859de00c6b2a0ebefcb5_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespaceaestate_1_1work_1_1_annotation_ac32df9034e26df39f1e2e10d6a8015ec}\label{namespaceaestate_1_1work_1_1_annotation_ac32df9034e26df39f1e2e10d6a8015ec}} 
\index{aestate.work.Annotation@{aestate.work.Annotation}!ReadXml@{ReadXml}}
\index{ReadXml@{ReadXml}!aestate.work.Annotation@{aestate.work.Annotation}}
\doxysubsubsection{\texorpdfstring{ReadXml()}{ReadXml()}}
{\footnotesize\ttfamily def aestate.\+work.\+Annotation.\+Read\+Xml (\begin{DoxyParamCaption}\item[{}]{filename }\end{DoxyParamCaption})}

\begin{DoxyVerb}读取xml\end{DoxyVerb}
 

在文件 Annotation.\+py 第 217 行定义.

这是这个函数的调用关系图\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d9/db8/namespaceaestate_1_1work_1_1_annotation_ac32df9034e26df39f1e2e10d6a8015ec_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespaceaestate_1_1work_1_1_annotation_ac08818b3674c675825f79597c16a79dd}\label{namespaceaestate_1_1work_1_1_annotation_ac08818b3674c675825f79597c16a79dd}} 
\index{aestate.work.Annotation@{aestate.work.Annotation}!Select@{Select}}
\index{Select@{Select}!aestate.work.Annotation@{aestate.work.Annotation}}
\doxysubsubsection{\texorpdfstring{Select()}{Select()}}
{\footnotesize\ttfamily def aestate.\+work.\+Annotation.\+Select (\begin{DoxyParamCaption}\item[{str}]{sql }\end{DoxyParamCaption})}

\begin{DoxyVerb}快捷的查询装饰器

使用此装饰器,可以将大量重复代码继承到此装饰器内部实现

使用方法:
    @Select(sql="SELECT * FROM demo_table WHERE t_id<=%s AND t_msg like %s", params=['${t_id}', '%${t_msg}%'])

    sql:执行的sql语句,需要加密的参数使用`%s`表示

    params:加密参数的内容,标记使用传参请使用`${字段名}`表示\end{DoxyVerb}
 

在文件 Annotation.\+py 第 32 行定义.

\mbox{\Hypertarget{namespaceaestate_1_1work_1_1_annotation_aff598086972f97be72f7422f46108015}\label{namespaceaestate_1_1work_1_1_annotation_aff598086972f97be72f7422f46108015}} 
\index{aestate.work.Annotation@{aestate.work.Annotation}!SelectAbst@{SelectAbst}}
\index{SelectAbst@{SelectAbst}!aestate.work.Annotation@{aestate.work.Annotation}}
\doxysubsubsection{\texorpdfstring{SelectAbst()}{SelectAbst()}}
{\footnotesize\ttfamily def aestate.\+work.\+Annotation.\+Select\+Abst (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



在文件 Annotation.\+py 第 65 行定义.

这是这个函数的调用关系图\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d9/db8/namespaceaestate_1_1work_1_1_annotation_aff598086972f97be72f7422f46108015_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespaceaestate_1_1work_1_1_annotation_a0c2a2efda9eb54562253e840bb5d0f49}\label{namespaceaestate_1_1work_1_1_annotation_a0c2a2efda9eb54562253e840bb5d0f49}} 
\index{aestate.work.Annotation@{aestate.work.Annotation}!Table@{Table}}
\index{Table@{Table}!aestate.work.Annotation@{aestate.work.Annotation}}
\doxysubsubsection{\texorpdfstring{Table()}{Table()}}
{\footnotesize\ttfamily def aestate.\+work.\+Annotation.\+Table (\begin{DoxyParamCaption}\item[{}]{name,  }\item[{}]{msg,  }\item[{$\ast$$\ast$}]{kwargs }\end{DoxyParamCaption})}

\begin{DoxyVerb}标注该类为一个表
:param name:表的名称
:param msg:表的描述
:return:
\end{DoxyVerb}
 

在文件 Annotation.\+py 第 14 行定义.

这是这个函数的调用关系图\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d9/db8/namespaceaestate_1_1work_1_1_annotation_a0c2a2efda9eb54562253e840bb5d0f49_icgraph}
\end{center}
\end{figure}
